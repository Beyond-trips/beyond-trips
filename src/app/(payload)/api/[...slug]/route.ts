// src/app/(payload)/api/[...slug]/route.ts
/* THIS FILE WAS GENERATED BY PAYLOAD */
/* YOU CAN EXTEND IT, BUT CHANGES MIGHT BE OVERWRITTEN */
import { getPayloadHMR } from '@payloadcms/next/utilities'
import { NextRequest, NextResponse } from 'next/server'
import configPromise from '../../../../payload.config'

// Import partner registration functions
import { 
  startPartnerRegistration,
  verifyEmail,
  resendVerificationCode,
  createAdCampaign,
  getSubscriptionPlans,
  setupPaymentBudgeting,
  completeRegistration,
  getRegistrationStatus
} from '../../../../endpoints/partnerRegistration'

// Import the REST handler from Payload
import { REST_GET, REST_POST, REST_DELETE, REST_PATCH, REST_PUT } from '@payloadcms/next/routes'

export async function GET(
  req: NextRequest,
  { params }: { params: Promise<{ slug: string[] }> }
) {
  const resolvedParams = await params
  const slug = resolvedParams.slug
  const pathname = '/' + slug.join('/')

  // Handle test-email endpoint
  if (pathname === '/test-email') {
    const { testEmailConnection } = await import('../../../../lib/email')
    const result = await testEmailConnection()
    return NextResponse.json(result)
  }

  // Handle partner GET endpoints
  if (pathname === '/partner/subscription-plans') {
    const payload = await getPayloadHMR({ config: configPromise })
    const payloadRequest = {
      payload,
      headers: req.headers,
      url: req.url,
      method: req.method,
    }
    return await getSubscriptionPlans(payloadRequest as any)
  }

  if (pathname.startsWith('/partner/status/')) {
    const payload = await getPayloadHMR({ config: configPromise })
    const payloadRequest = {
      payload,
      headers: req.headers,
      url: req.url,
      method: req.method,
    }
    return await getRegistrationStatus(payloadRequest as any)
  }

  // Let Payload handle all other GET requests
  return REST_GET(req, { params: resolvedParams })
}

export async function POST(
  req: NextRequest,
  { params }: { params: Promise<{ slug: string[] }> }
) {
  const resolvedParams = await params
  const slug = resolvedParams.slug
  const pathname = '/' + slug.join('/')

  // Handle partner POST endpoints
  if (pathname.startsWith('/partner/')) {
    const payload = await getPayloadHMR({ config: configPromise })
    
    const payloadRequest = {
      payload,
      headers: req.headers,
      json: async () => {
        const text = await req.text()
        return text ? JSON.parse(text) : {}
      },
      body: req.body,
      url: req.url,
      method: req.method,
    }

    switch (pathname) {
      case '/partner/register/start':
        return await startPartnerRegistration(payloadRequest as any)
      case '/partner/verify-email':
        return await verifyEmail(payloadRequest as any)
      case '/partner/resend-code':
        return await resendVerificationCode(payloadRequest as any)
      case '/partner/create-campaign':
        return await createAdCampaign(payloadRequest as any)
      case '/partner/setup-payment':
        return await setupPaymentBudgeting(payloadRequest as any)
      case '/partner/complete':
        return await completeRegistration(payloadRequest as any)
      default:
        return NextResponse.json({
          error: 'Partner endpoint not found',
          path: pathname,
          method: 'POST'
        }, { status: 404 })
    }
  }

  // Handle custom auth endpoints (OTP system)
  if (pathname === '/auth/generate-otp' || pathname === '/auth/verify-otp') {
    const payload = await getPayloadHMR({ config: configPromise })
    
    if (pathname === '/auth/generate-otp') {
      const body = await req.json()
      const { email } = body

      if (!email) {
        return NextResponse.json({ error: 'Email is required' }, { status: 400 })
      }

      const users = await payload.find({
        collection: 'users',
        where: { email: { equals: email } },
        limit: 1,
      })

      let user
      if (users.docs.length === 0) {
        user = await payload.create({
          collection: 'users',
          data: {
            email,
            password: 'TempPassword123!',
            username: email.split('@')[0],
            role: 'user',
            emailVerified: false,
          },
        })
      } else {
        user = users.docs[0]
      }

      const otp = Math.floor(100000 + Math.random() * 900000).toString()
      const otpExpiry = new Date(Date.now() + 10 * 60 * 1000)

      await payload.update({
        collection: 'users',
        id: user.id,
        data: {
          otp,
          otpExpiry: otpExpiry.toISOString(),
        },
      })

      const { sendOTPEmail } = await import('../../../../lib/email')
      const emailResult = await sendOTPEmail(email, otp)

      return NextResponse.json({
        success: true,
        message: emailResult.success 
          ? 'OTP sent to your email successfully' 
          : 'OTP generated but email sending failed',
        userId: user.id,
        emailSent: emailResult.success,
        otp: otp
      })
    }

    if (pathname === '/auth/verify-otp') {
      const body = await req.json()
      const { email, otp } = body

      if (!email || !otp) {
        return NextResponse.json({ error: 'Email and OTP are required' }, { status: 400 })
      }

      const users = await payload.find({
        collection: 'users',
        where: { email: { equals: email } },
        limit: 1,
      })

      if (users.docs.length === 0) {
        return NextResponse.json({ error: 'User not found' }, { status: 400 })
      }

      const user = users.docs[0]

      if (!user.otp || user.otp !== otp) {
        return NextResponse.json({ error: 'Invalid OTP' }, { status: 400 })
      }

      if (!user.otpExpiry || new Date(user.otpExpiry) <= new Date()) {
        return NextResponse.json({ error: 'OTP has expired' }, { status: 400 })
      }

      await payload.update({
        collection: 'users',
        id: user.id,
        data: {
          otp: null,
          otpExpiry: null,
          emailVerified: true,
        },
      })

      return NextResponse.json({
        success: true,
        message: 'OTP verified successfully',
        user: {
          id: user.id,
          email: user.email,
          username: user.username
        }
      })
    }
  }

  // Let Payload handle all other POST requests (including /users/login)
  return REST_POST(req, { params: resolvedParams })
}

export async function DELETE(
  req: NextRequest,
  { params }: { params: Promise<{ slug: string[] }> }
) {
  const resolvedParams = await params
  return REST_DELETE(req, { params: resolvedParams })
}

export async function PATCH(
  req: NextRequest,
  { params }: { params: Promise<{ slug: string[] }> }
) {
  const resolvedParams = await params
  return REST_PATCH(req, { params: resolvedParams })
}

export async function PUT(
  req: NextRequest,
  { params }: { params: Promise<{ slug: string[] }> }
) {
  const resolvedParams = await params
  return REST_PUT(req, { params: resolvedParams })
}